/* 
HOW TO USE:

Add `#include "../path/to/KinLimitsDriver_template.any"` in the beginning
of your main file. Then create the `KinLimitsDriver` class inside Main after 
the human model is included in the model:

EXAMPLE:
```
#include "../path/to/KinLimitsDriver_template.any"

Main = {

  // It is important that the human model is include
  // before the JointLimit template. This is to ensure
  // that all BM statements are defined.
  #include "<ANYBODY_PATH_BODY>/HumanModel.any"


  CreateJointLimitDrivers JointLimits(
      ARM_RIGHT = BM_ARM_RIGHT,
      ARM_LEFT = BM_ARM_LEFT,
      LEG_RIGHT = BM_LEG_RIGHT,
      LEG_LEFT = BM_LEG_LEFT,
      TRUNK_NECK = BM_TRUNK_NECK
   ) = {
      // Example of changing af few of the limits
      Limits.Trunk.PelvisThoraxExtension = {-90, 90};
      Limits.Right.ElbowPronation = {-90, 90};
   }; 
      
```

If some joint should not have limits, the class accepts arguments for disabling individual joint limits. eq

```
  CreateJointLimitDrivers JointLimits(
    PELVIS_THORAX_LATERAL_BENDING = "Off"
    ... 
```

*/


#include "helper_macros.any"

#class_template KinLimitsDriver(AnyKinMeasure &KinMeasure, _DEBUG=0) {

  
#var AnyVar LowerLimit; 
#var AnyVar HighLimit;
  
#var AnyVar DriverPhaseIn = 0.01*(HighLimit - LowerLimit) ;
#var AnyVar LowerLimitHard= LowerLimit - DriverPhaseIn ;
#var AnyVar HighLimitHard= HighLimit + DriverPhaseIn ;

#var AnyVar ErrorAtHardLimit = 1;
#var AnyVar ErrorAtLowerHardLimit = ErrorAtHardLimit;
#var AnyVar ErrorAtHighHardLimit = ErrorAtHardLimit;

#var AnyVar MeasureConversion = 1;

/// Generates an non-equisample abscissa axis for the data. 
/// Most points are clustered around the transition zones.
AnyFunInterpol AbscissaFunction = 
{
  AnyFloat LowPhaseIn = abs(.LowerLimit-.LowerLimitHard);
  AnyFloat HighPhaseIn = abs(.HighLimit-.HighLimitHard);
  AnyFloat TotalRange = abs(.LowerLimitHard-.HighLimitHard);

  #var Type = Bspline;
  #var BsplineOrder = 8;
       
  #var AnyMatrix M = {
                      {0, .LowerLimitHard-1e1*LowPhaseIn-1e1*TotalRange},
                      {80, .LowerLimitHard-1e1*LowPhaseIn},
                      {160,  .LowerLimitHard},
                      {490, .LowerLimit},
                      {510, .HighLimit},
                      {840, .HighLimitHard},
                      {920, .HighLimitHard+1e1*HighPhaseIn},
                      {999, .HighLimitHard+1e1*HighPhaseIn+1e1*TotalRange}                    
                    };  

                    
  T    = M'[0];
  Data = {M'[1]};
};



AnyFunInterpol JointLimitErrorFunction= 
{  
  Type = Bspline;
  T = .AbscissaFunction(1.0*iarr(0,999))' ;
  Data = {.ErrorAtLowerHardLimit*SMOOTHRAMP(.LowerLimit, .LowerLimitHard, T) + 
          .ErrorAtHighHardLimit*SMOOTHRAMP(.HighLimit, .HighLimitHard, T)} ;
};

#if _DEBUG
AnyFunInterpol &FT = JointLimitErrorFunction;
AnyFloat Test = {FT (-10.0), FT( -5.0), FT (0.0), FT (5.0), FT (10.0)}; 
AnyFloat test_fullrange = JointLimitErrorFunction(1.0*iarr(ceil(min(AbscissaFunction.M'[1])),floor(max(AbscissaFunction.M'[1]))))';
AnyFloat range = LINSPACE(LowerLimitHard, HighLimitHard,1000);
AnyFloat test_range = JointLimitErrorFunction(range)';
#endif


AnyKinMeasureFunComb1 JointLimitMeasure = {
  AnyKinMeasureLinComb ConvertedMeasure = {
    AnyKinMeasure &ref = ..KinMeasure;
    Coef  = {{..MeasureConversion }};
    OutDim = 1;
  };
  Functions = {&.JointLimitErrorFunction};
};

AnyKinEqSimpleDriver JointLimitDriver = 
{
  AnyKinMeasureFunComb1 & ref = .JointLimitMeasure;
  #var DriverPos = {0};
  #var DriverVel = {0};
  Reaction.Type = {Off};
  CType = {Soft};
  AnyFunConst ConstFun = 
  { 
    #var Value = {1};
  };
  #var WeightFun = {&ConstFun};      
};


};




